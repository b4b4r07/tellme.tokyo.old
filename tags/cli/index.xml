<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cli on TELLME.TOKYO</title>
    <link>http://tellme.tokyo/tags/cli/</link>
    <description>Recent content in Cli on TELLME.TOKYO</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Thu, 16 Jul 2015 19:02:20 +0900</lastBuildDate>
    <atom:link href="http://tellme.tokyo/tags/cli/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>優れた dotfiles を設計する</title>
      <link>http://tellme.tokyo/post/2015/07/16/dotfiles/</link>
      <pubDate>Thu, 16 Jul 2015 19:02:20 +0900</pubDate>
      
      <guid>http://tellme.tokyo/post/2015/07/16/dotfiles/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/b4b4r07/dotfiles&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/b4b4r07/screenshots/master/dotfiles/title.png&#34; alt=&#34;&#34; /&gt;
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;OS のクリーンインストールは面倒くさい． アプリケーションをいちいちダウンロードしてきて，普段の勝手と同じになるように設定する必要がある．CLI においても同じで，設定ファイルをいちいち書いたり，普段どんなプラグインを使っていたかを思い出してダウンロードするのは面倒だ．
よくあるのは &lt;code&gt;.vimrc&lt;/code&gt; などの設定ファイルを Dropbox や GitHub に置いておいて，環境を作り直したときにコピーする手法だ．
dotfiles はその手法の延長線上にあって，より便利に高速化・自動化した方法だ．&lt;/p&gt;

&lt;p&gt;dotfiles とは UNIX 系の OS でいう設定ファイルのことで，ファイル名がドット &lt;code&gt;.&lt;/code&gt; から始まることからそう呼ばれている．&lt;/p&gt;

&lt;h1 id=&#34;tl-dr:f6c8ac5bb47a72f181aa6c9def901a4c&#34;&gt;TL;DR&lt;/h1&gt;

&lt;p&gt;HTTP 経由でインストールできる dotfiles をつくって 1 分で環境構築を終わらせる．&lt;/p&gt;

&lt;h1 id=&#34;getting-started:f6c8ac5bb47a72f181aa6c9def901a4c&#34;&gt;Getting Started&lt;/h1&gt;

&lt;p align=&#34;center&#34;&gt;
  &lt;a href=&#34;http://b4b4r07.com/dotfiles&#34;&gt;
  &lt;img width=&#34;35%&#34; src=&#34;https://raw.githubusercontent.com/b4b4r07/screenshots/master/dotfiles/symbol.png&#34;&gt;
  &lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;dotfiles を始めるのはとても簡単だ．GitHub アカウントがあるなら，「dotfiles」の名前でリポジトリを作って自分のドットファイルを転送するだけ．別に dotfiles という名前である必要はないが，GitHub をウォッチすればこの名前でホスティングしているケースが圧倒的に多い（極稀に config や rcfiles といった名前も見かける）．&lt;/p&gt;

&lt;p&gt;dotfiles というのは GitHub にアップロードしただけじゃうまく使えない．ホームディレクトリにコピーする必要があるのだが，環境を変えるごとに&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ cp dotfiles/.vimrc ~/.vimrc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とするのはとても面倒で，しかもドットファイルがたくさんあるなら尚更．まずはこれを自動化しよう．&lt;/p&gt;

&lt;p&gt;簡単なシェルスクリプトを書くだけでいい．Ruby（Rakefile）や Lua など他のスクリプト言語で書いている人も見かけるが，基本的に環境を構築するときは何もインストールされていない状態なので，これらの高級言語や枯れていない技術などは使えない可能性がある．シェルスクリプトや make はこういった心配がないので重宝する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#...

for f in .??*
do
    [ &amp;quot;$f&amp;quot; = &amp;quot;.git&amp;quot; ] &amp;amp;&amp;amp; continue

    ln -snfv &amp;quot;$f&amp;quot; &amp;quot;$HOME&amp;quot;/&amp;quot;$f&amp;quot;
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これがコピー・リンク用のスクリプトで，いわゆるインストールスクリプト（ &lt;em&gt;installation script&lt;/em&gt; ）である．ドットファイルを列挙（&lt;code&gt;.??*&lt;/code&gt;）して &lt;code&gt;ln&lt;/code&gt; を実行している．コピーではなくシンボリックリンクなのは，変更の同期を楽にするためである．設定を変更したり改修したりしたときに，よしなに dotfiles へ同期されるので，あとは &lt;code&gt;git push&lt;/code&gt; をするだけという環境までもっていける．&lt;/p&gt;

&lt;p&gt;&lt;code&gt;.git&lt;/code&gt; や &lt;code&gt;.DS_Store&lt;/code&gt; などの不要なドットファイルは実行されないようにすればよい．&lt;/p&gt;

&lt;h1 id=&#34;http-経由でインストールする:f6c8ac5bb47a72f181aa6c9def901a4c&#34;&gt;HTTP 経由でインストールする&lt;/h1&gt;

&lt;p align=&#34;center&#34;&gt;
  &lt;a href=&#34;http://b4b4r07.com/dotfiles&#34;&gt;
  &lt;img width=&#34;35%&#34; src=&#34;https://raw.githubusercontent.com/b4b4r07/screenshots/master/dotfiles/http.png&#34;&gt;
  &lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;前項で dotfiles の基本は完成した．あとは環境が壊れたり新しくなったときに，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ git clone htttp://github.com/&amp;quot;${username}&amp;quot;/dotfile.git
$ cd dotfiles
$ ./install.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を実行するだけである．しかし，これでは少し問題が残っている．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;コマンドを 3 つ打たなければならない&lt;/li&gt;
&lt;li&gt;git がない場合&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;特に後者は面倒で，git がないと git のインストールからスタートになる．一般ユーザなどで git をインストールできないなどの場合は更に厄介で，GitHub にアップされている dotfiles の tarball や zipball の URL を取得して，&lt;code&gt;curl&lt;/code&gt; や &lt;code&gt;wget&lt;/code&gt; を使う必要がある．&lt;/p&gt;

&lt;p&gt;ここらへんの障害を吸収したスクリプトがこれ．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#...

DOTPATH=~/.dotfiles

# git が使えるなら git
if has &amp;quot;git&amp;quot;; then
    git clone --recursive &amp;quot;$GITHUB_URL&amp;quot; &amp;quot;$DOTPATH&amp;quot;

# 使えない場合は curl か wget を使用する
elif has &amp;quot;curl&amp;quot; || has &amp;quot;wget&amp;quot;; then
    tarball=&amp;quot;https://github.com/b4b4r07/dotfiles/archive/master.tar.gz&amp;quot;
    
    # どっちかでダウンロードして，tar に流す
    if has &amp;quot;curl&amp;quot;; then
        curl -L &amp;quot;$tarball&amp;quot;

    elif has &amp;quot;wget&amp;quot;; then
        wget -O - &amp;quot;$tarball&amp;quot;

    fi | tar xv -
    
    # 解凍したら，DOTPATH に置く
    mv -f dotfiles-master &amp;quot;$DOTPATH&amp;quot;

else
    die &amp;quot;curl or wget required&amp;quot;
fi

cd ~/.dotfiles
if [ $? -ne 0 ]; then
    die &amp;quot;not found: $DOTPATH&amp;quot;
fi

# 移動できたらリンクを実行する
for f in .??*
do
    [ &amp;quot;$f&amp;quot; = &amp;quot;.git&amp;quot; ] &amp;amp;&amp;amp; continue

    ln -snfv &amp;quot;$DOTPATH/$f&amp;quot; &amp;quot;$HOME/$f&amp;quot;
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;長いようにみえるが，律儀に条件分岐して実行するだけなので意外と簡単だ．あとはこれを &lt;code&gt;install.sh&lt;/code&gt; といった分かりやすいファイル名にしてアップロードする．&lt;/p&gt;

&lt;p&gt;さて，&lt;code&gt;curl&lt;/code&gt; でこれにアクセスするが，そのままだと HTML の構造ごと見えてしまうので github.com のサブドメインに raw を付けて実行する&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ curl -L raw.github.com/&amp;quot;${username}&amp;quot;/dotfiles/&amp;quot;${branch:-master}&amp;quot;/install.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;リダイレクトが発生するので &lt;code&gt;-L&lt;/code&gt; オプションはマストになる．こうすると，先ほどの &lt;code&gt;install.sh&lt;/code&gt; が表示されると思う．あとはこれをシェルに渡すだけだ．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ curl -L raw.github.com/&amp;quot;${username}&amp;quot;/dotfiles/master/install.sh | bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでシェル環境の構築が完了したのではなかろうか．ワンコマンドで済み，依存するツールを最小限にすることができた．raw 付きの URL も覚えられなくはない長さなので，すぐさまこれをタイプするだけで OK だ．&lt;/p&gt;

&lt;p&gt;しかし，リンクが切れたとかで，再度 &lt;code&gt;install.sh&lt;/code&gt; を実行するときや，HTTP 経由ではなくローカルから実行するには少し工夫が必要になる．このままだと，dotfiles のインストールから再開されてしまうからだ．&lt;/p&gt;

&lt;h1 id=&#34;deploy-と-initialize:f6c8ac5bb47a72f181aa6c9def901a4c&#34;&gt;deploy と initialize&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;deploy&lt;/em&gt; と &lt;em&gt;initialize&lt;/em&gt; については，下の記事で解説したがもう一度おさらいしようと思う．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/b4b4r07/items/b70178e021bef12cd4a2&#34;&gt;最強の dotfiles 駆動開発と GitHub で管理する運用方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;deploy&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;とは&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;deploy&lt;/em&gt; とは，dotfiles にあるドットファイルをホームディレクトリに展開することを指す．便宜的にそう読んでいるだけで，その実態はコピーであったりシンボリックリンクを張ることをいっている．&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;initialize&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;とは&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;initialize&lt;/em&gt; とは，環境を再現するのに必要なソフトウェアをインストールしたり，プラグインのダウンロード・セットアップやディレクトリ名を英語化したりなどの最後の仕上げ部分を指す．アップデートを除いて一回きりの設定なので便宜上こう呼ぶ&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;これらを一緒くたにしてしまっているインストールスクリプト（ &lt;em&gt;installation script&lt;/em&gt; ）は設計上よろしくない．何故かと言うと，その説明にもある通り，&lt;em&gt;initialize&lt;/em&gt; はセットアップ時の一回きりしか実行されないからだ．一方で &lt;em&gt;deploy&lt;/em&gt; は何度も実行する場面がある．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;リンクが切れた時&lt;/li&gt;
&lt;li&gt;リンクされたファイルを削除した時&lt;/li&gt;
&lt;li&gt;新しいファイルを dotfiles に追加した時&lt;/li&gt;
&lt;li&gt;など&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;このときに，&lt;em&gt;initialize&lt;/em&gt; を動き出すとはっきりいって面倒で，Ctrl-C で中断したりリンク張るためにスクリプトからリンクを実行している部分を切り出して別ファイルで実行したりしなければならない．&lt;/p&gt;

&lt;h2 id=&#34;設定例:f6c8ac5bb47a72f181aa6c9def901a4c&#34;&gt;設定例&lt;/h2&gt;

&lt;p&gt;例えば処理部分で切り分けて，オプションやサブコマンドで対応したりする．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

deploy() {
	#...
	echo &amp;quot;deploy&amp;quot;
}

initalize() {
	#...
	echo &amp;quot;init&amp;quot;
}

if [ &amp;quot;$1&amp;quot; = &amp;quot;deploy&amp;quot; -o &amp;quot;$1&amp;quot; = &amp;quot;d&amp;quot; ]; then
	deploy
elif [ &amp;quot;$1&amp;quot; = &amp;quot;init&amp;quot; -o &amp;quot;$1&amp;quot; = &amp;quot;i&amp;quot; ; then
	initalize
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;オプションにすると &lt;code&gt;curl&lt;/code&gt; でインストールするときに少しわかりづらい記述になってしまう．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ curl -L dot.example.com | bash -s -d
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;b4b4r07-dotfiles:f6c8ac5bb47a72f181aa6c9def901a4c&#34;&gt;b4b4r07/dotfiles&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/b4b4r07/dotfiles&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/b4b4r07/screenshots/master/dotfiles/logo.png&#34; alt=&#34;&#34; /&gt;
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;おおまかに優れた dotfiles の設計について説いた．次は筆者のリポジトリを例に見ていこうと思う．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/b4b4r07/dotfiles&#34;&gt;b4b4r07/dotfiles ❤ GitHub&lt;/a&gt; &lt;a href=&#34;https://github.com/b4b4r07/dotfiles&#34; title=&#34;b4b4r07/dotfiles&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/stars/b4b4r07/dotfiles.svg?style=flat-square&#34; alt=&#34;&#34; /&gt;
&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;Testing my dotfiles repo on OS X to get my work environment ready in just a few moments. #VIM + #ZSH + #TMUX = Best Developer Environment &lt;a href=&#34;http://b4b4r07.com/dotfiles&#34;&gt;http://b4b4r07.com/dotfiles&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;筆者の場合，インストールスクリプト（ &lt;em&gt;installation script&lt;/em&gt; ）の他に，後述するが make を使っている．make を使うのは環境依存性の排除を重視しているからだ．dotfiles のセットアップ時は，環境が整っていない状態なのでなるべくツールの依存性を少なくしなければならない．make であれば、だいたいの Unix ライクシステムで利用できる．環境依存性を少なくするベストプラクティスは Bourne Shell，make を使うことだ．&lt;/p&gt;

&lt;h2 id=&#34;インストール:f6c8ac5bb47a72f181aa6c9def901a4c&#34;&gt;インストール&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;curl&lt;/code&gt; でインストールを開始する．&lt;code&gt;wget&lt;/code&gt; でも良い．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ bash -c &amp;quot;$(curl -L dot.b4b4r07.com)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上の方法でなく，&lt;code&gt;curl -L dot.b4b4r07.com | sh&lt;/code&gt; でもいいが，これだとサブシェル上でインストールが開始される．この dotfiles のインストールスクリプト（ &lt;em&gt;installation script&lt;/em&gt; ）はシェルの再起動も自動化しているため，それを有効化するためにはカレントシェルで実行する必要がある．&lt;/p&gt;

&lt;p&gt;このワンライナーにより，&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;dotfiles をダウンロードする．&lt;code&gt;git clone&lt;/code&gt; で引っ張ってくるが，git がない場合は &lt;code&gt;curl&lt;/code&gt; または &lt;code&gt;wget&lt;/code&gt; を使う&lt;/li&gt;
&lt;li&gt;次に &lt;code&gt;make deploy&lt;/code&gt; を実行する（やっていることは，各ドットファイルをホームディレクトリにリンクする）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ドットファイルは，ダウンロードしたディレクトリを起点に make によってリンクされる．また，そのディレクトリをそれ以後，そのユーザの dotfiles リポジトリとして扱う．そのパスは &lt;code&gt;$DOTPATH&lt;/code&gt; で管理しているので，変更したい場合は，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ DOTPATH=/path/to/dotfiles curl -L ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;として実行する（ただし事前に export されている必要がある）．デフォルトの &lt;code&gt;$DOTPATH&lt;/code&gt; は &lt;code&gt;~/.dotfiles&lt;/code&gt;．&lt;/p&gt;

&lt;p&gt;引数に &lt;code&gt;init&lt;/code&gt; を渡すと，&lt;code&gt;make init&lt;/code&gt; も実行する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ bash -c &amp;quot;$(curl -L dot.b4b4r07.com)&amp;quot; -s init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;アップデートも簡単で，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ make update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすると，すぐさま最新版にしてくれる．make を使ったことで処理の切り分けが簡単になった．&lt;/p&gt;

&lt;h2 id=&#34;ロジック:f6c8ac5bb47a72f181aa6c9def901a4c&#34;&gt;ロジック&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/b4b4r07/screenshots/master/dotfiles/components_ja.png&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/b4b4r07/screenshots/master/dotfiles/components_ja.png&#34; alt=&#34;&#34; /&gt;
&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;curl&lt;/code&gt; が参照するのは GitHub にホストされた &lt;code&gt;etc/install&lt;/code&gt; の raw ファイル&lt;/li&gt;
&lt;li&gt;&lt;code&gt;etc/install&lt;/code&gt; はインストールスクリプト（ &lt;em&gt;installation script&lt;/em&gt; ）であると同時に，それ自体がライブラリになっており、呼び出し方によってライブラリかインストールスクリプト（*installation script*）かを決めている&lt;/li&gt;
&lt;li&gt;dotfiles に同梱されている多くのコマンドやスクリプトは，このライブラリを参照している&lt;/li&gt;
&lt;li&gt;そのパス解決に &lt;code&gt;$DOTPATH&lt;/code&gt; を使用する&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$DOTPATH&lt;/code&gt; はホームディレクトリにリンクされたドットファイル &lt;code&gt;.path&lt;/code&gt; によって決定する&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;dotpath:f6c8ac5bb47a72f181aa6c9def901a4c&#34;&gt;DOTPATH&lt;/h2&gt;

&lt;p&gt;dotfiles に関してたった一つだけ，専用の環境変数 DOTPATH を設けている．それは dotfiles ディレクトリのパスを知る変数で，後述する vital ライブラリや init スクリプトのパス解決に使われる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

. &amp;quot;$DOTPATH&amp;quot;/etc/lib/vital.sh

#...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;.path&lt;/code&gt; というドットファイルをホームディレクトリにリンクすることで，dotfiles のパスを辿っている．コマンド化させた &lt;code&gt;dotpath&lt;/code&gt; を用意しているので，実行するだけで簡単に取得できる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ dotpath
/home/b4b4r07/.dotfiles
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;make:f6c8ac5bb47a72f181aa6c9def901a4c&#34;&gt;make&lt;/h2&gt;

&lt;p&gt;この dotfiles では，make がすべての起点になる．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;make deploy&lt;/code&gt;: ドットファイルをリンクする&lt;/li&gt;
&lt;li&gt;&lt;code&gt;make init&lt;/code&gt;: 環境構築をする&lt;/li&gt;
&lt;li&gt;&lt;code&gt;make list&lt;/code&gt;: リンクされるドットファイルをリストする&lt;/li&gt;
&lt;li&gt;&lt;code&gt;make test&lt;/code&gt;: dotfiles を検証する&lt;/li&gt;
&lt;li&gt;&lt;code&gt;make clean&lt;/code&gt;: dotfiles とドットファイルを削除する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ユーザはそれ以外のディレクトリを覗く必要もないし，それ以外のファイルを実行する必要もない．&lt;/p&gt;

&lt;h3 id=&#34;deploy:f6c8ac5bb47a72f181aa6c9def901a4c&#34;&gt;deploy&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;deploy&lt;/em&gt; とは，ドットファイルをホームディレクトリにリンクすることをいう．&lt;code&gt;.bashrc&lt;/code&gt; や &lt;code&gt;.vimrc&lt;/code&gt; などのドットファイル（ファイル名の頭に &lt;code&gt;.&lt;/code&gt; が付く）はホームディレクトリにあると各種アプリケーションが読み込むような慣習があるためだ．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-make&#34;&gt;EXCLUSIONS := .DS_Store .git .gitmodules .travis.yml
CANDIDATES := $(wildcard .??*) bin
DOTFILES   := $(filter-out $(EXCLUSIONS), $(CANDIDATES))
DOTPATH    := $(realpath $(dir $(lastword $(MAKEFILE_LIST))))

deploy:
	@$(foreach val, $(DOTFILES), ln -sfnv $(abspath $(val)) $(HOME)/$(val);)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;init:f6c8ac5bb47a72f181aa6c9def901a4c&#34;&gt;init&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;initialize&lt;/em&gt; とは，各種アプリケーションの設定ファイル&lt;strong&gt;以外&lt;/strong&gt;の環境設定やその他をいう．例えば，Vim では &lt;code&gt;.vimrc&lt;/code&gt; で行う設定以外にプラグインのダウンロードという作業が必要である．また，普段使うソフトウェアのインストールやローカライズなど，環境構築で欠かせないプロセスをプログラム化したのがこのステップである．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-make&#34;&gt;init:
	@DOTPATH=$(DOTPATH) bash $(DOTPATH)/etc/init/init.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;make init&lt;/code&gt; は &lt;code&gt;$DOTPATH/etc/init/init.sh&lt;/code&gt; を実行するだけである．では，そのシェルスクリプトは何をしているのかというと，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#...

for i in &amp;quot;$DOTPATH&amp;quot;/etc/init/&amp;quot;$(get_os)&amp;quot;/*[^init].sh
do
    if [ -f &amp;quot;$i&amp;quot; ]; then
        e_arrow &amp;quot;$(basename &amp;quot;$i&amp;quot;)&amp;quot;; bash &amp;quot;$i&amp;quot;
    else
        continue
    fi
done

#...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行しているプラットフォームで必要なプロセスを記述したシェルスクリプトを呼び出している．こうすることで一括した実行が可能になる．また，&lt;em&gt;deploy&lt;/em&gt; のときのように make で書けなくないが，テスタブルにする必要があるためシェルスクリプトに書き，それを make で呼ぶ形式になっている．&lt;/p&gt;

&lt;h3 id=&#34;test:f6c8ac5bb47a72f181aa6c9def901a4c&#34;&gt;test&lt;/h3&gt;

&lt;p&gt;dotfiles が正しくインストールできるか，付随するシェルスクリプトが正しく動作するかなどをチェックする．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ make test
 ✔ deploying dot files...OK
 ✔ linking valid paths...OK
 ✖ /Users/b4b4r07/.dotfiles/etc/test/redirect_test.sh: 17: unit1
 ➜ check shellcheck...
     ✔ /Users/b4b4r07/.dotfiles/etc/init/init.sh...OK
     ✔ /Users/b4b4r07/.dotfiles/etc/init/common/pygments.sh...OK
     ✔ /Users/b4b4r07/.dotfiles/etc/init/osx/brew.sh...OK
     ✔ /Users/b4b4r07/.dotfiles/etc/init/osx/bundle.sh...OK
     ✔ /Users/b4b4r07/.dotfiles/etc/init/osx/go.sh...OK
     ✔ /Users/b4b4r07/.dotfiles/etc/init/osx/pygments.sh...OK
     ✔ /Users/b4b4r07/.dotfiles/etc/init/osx/unlocalize.sh...OK
     ✔ /Users/b4b4r07/.dotfiles/etc/init/linux/chsh.sh...OK
     ✔ /Users/b4b4r07/.dotfiles/etc/init/linux/goal.sh...OK
     ✔ /Users/b4b4r07/.dotfiles/etc/init/linux/pygments.sh...OK
 ➜ test brew.sh...
     ✔ check if init script exists...OK
     ✔ check running...OK
 ➜ test bundle.sh...
     ✔ check if init script exists...OK
     ✔ check if Brewfile exists...OK
Files=5, Tests=6
make: *** [test] Error 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ローカルでは &lt;code&gt;make test&lt;/code&gt; とすると，テストが走る．見かけないエラーが出てきたら &lt;code&gt;--silent&lt;/code&gt; オプションを付けて実行する．ディレクトリの切り方は init のそれとほぼ同じで，Makefile からも，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-make&#34;&gt;test:
	@DOTPATH=$(DOTPATH) bash $(DOTPATH)/etc/test/test.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としているだけである．init 以外のテストスクリプトは &lt;code&gt;test/&lt;/code&gt; 直下に置く．例えば，raw ページのリダイレクトなどがある．&lt;/p&gt;

&lt;p&gt;CI as a Service は Travis CI でテストしている．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;language: c
os:
    - linux
    - osx

env:
  global:
    - DOTPATH=~/.dotfiles
    - GOPATH=~

install:
    - curl -L dot.b4b4r07.com | bash
    - cd $DOTPATH
    - make init

script:
    - make --silent test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;bash -c ...&lt;/code&gt; としていないのはシェルの再起動を防ぐためである．Travis CI でシェルを切り替えてしまうとテストするタスクも消え去るからである．&lt;/p&gt;

&lt;h2 id=&#34;vital-sh:f6c8ac5bb47a72f181aa6c9def901a4c&#34;&gt;vital.sh&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;vital.sh&lt;/code&gt; は最も重要なファイルの一つで，&lt;code&gt;../install&lt;/code&gt; を参照するシンボリックリンクのライブラリファイルである．&lt;/p&gt;

&lt;p&gt;挙動が面白いスクリプトで，コールのされかたによって &lt;code&gt;vital.sh&lt;/code&gt; として動作したり &lt;code&gt;install&lt;/code&gt; だったりする．&lt;code&gt;lib/install&lt;/code&gt; として振る舞うのは &lt;code&gt;bash -c ...&lt;/code&gt; か &lt;code&gt;... | bash&lt;/code&gt; で呼ばれたときのみ．つまり，&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;bash -c &amp;quot;$(curl -L dot.b4b4r07.com)&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;curl -L dot.b4b4r07.com | bash&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;のときである．&lt;code&gt;source&lt;/code&gt; で取り込まれたときは &lt;code&gt;vital.sh&lt;/code&gt; として振る舞い，それ以外（&lt;code&gt;bash vital.sh&lt;/code&gt; など）では実行されない．HTTP を通してインストールする場合，前者 2 種のどちらかであるし，ライブラリとして読み込む場合は，&lt;code&gt;source&lt;/code&gt; や &lt;code&gt;.&lt;/code&gt; コマンドが必要で，コマンドラインから実行するようなユースケースは想定されないからだ．&lt;/p&gt;

&lt;p&gt;&lt;code&gt;vital.sh&lt;/code&gt; にはたくさんのユーティリティがあって，プラットフォームを検知する関数や &lt;code&gt;$PLATFORM&lt;/code&gt; という環境変数，&lt;code&gt;has&lt;/code&gt;，&lt;code&gt;die&lt;/code&gt; など．&lt;/p&gt;

&lt;h1 id=&#34;まとめ:f6c8ac5bb47a72f181aa6c9def901a4c&#34;&gt;まとめ&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ bash -c &amp;quot;$(curl -L dot.b4b4r07.com)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上で解説したテクニックや設計を集合させると，下の Gif アニメーションのようにあっさりと環境構築が可能になる．たったワンコマンドで数分，数秒で完了する．&lt;em&gt;initialize&lt;/em&gt; までやりたいなら &lt;code&gt;-s init&lt;/code&gt; をつけるだけ．&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/b4b4r07/dotfiles&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/b4b4r07/screenshots/master/dotfiles/demo.gif&#34; alt=&#34;&#34; /&gt;
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;これらの設計，つまり&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;インストールスクリプト（ &lt;em&gt;installation script&lt;/em&gt; ）を用意する&lt;/li&gt;
&lt;li&gt;HTTP 経由で利用できるように工夫する&lt;/li&gt;
&lt;li&gt;&lt;em&gt;deploy&lt;/em&gt; と &lt;em&gt;initialize&lt;/em&gt; は分ける&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;をベースに dotfiles をつくっていくと簡単に環境の再現ができるようになる．たかがターミナルの設定とはいえ，環境の再構築は簡単にできるに越したことはないと思う．ワンコマンドですぐに再構築できるのは環境が壊れることを恐れさせない強みになるからだ．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>開発者から見た UNIX 哲学とコマンドラインツールと Go言語</title>
      <link>http://tellme.tokyo/post/2015/06/23/unix_cli_tool_go/</link>
      <pubDate>Tue, 23 Jun 2015 15:47:51 +0900</pubDate>
      
      <guid>http://tellme.tokyo/post/2015/06/23/unix_cli_tool_go/</guid>
      <description>

&lt;p&gt;CLI（Command-line Interface）ツールが好きで自分でもよく作るし，よく使っている．最近は高速で，かつクロスコンパイルが容易な Go 言語がその開発に使われることが多いようだ．実際に筆者も拙劣ながら Go 言語で何個かリリースしている．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/b4b4r07/gch&#34;&gt;b4b4r07/gch&lt;/a&gt; &lt;a href=&#34;https://github.com/b4b4r07/gch&#34; title=&#34;b4b4r07/gch - GitHub&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/stars/b4b4r07/gch.svg?style=flat-square&#34; alt=&#34;&#34; /&gt;
&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/b4b4r07/goal&#34;&gt;b4b4r07/goal&lt;/a&gt; &lt;a href=&#34;https://github.com/b4b4r07/goal&#34; title=&#34;b4b4r07/goal - GitHub&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/stars/b4b4r07/goal.svg?style=flat-square&#34; alt=&#34;&#34; /&gt;
&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/b4b4r07/gomi&#34;&gt;b4b4r07/gomi&lt;/a&gt; &lt;a href=&#34;https://github.com/b4b4r07/gomi&#34; title=&#34;b4b4r07/gomi - GitHub&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/stars/b4b4r07/gomi.svg?style=flat-square&#34; alt=&#34;&#34; /&gt;
&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CLI ツールの歴史はとても長く，過去たくさんの素晴らしい資産と独自の哲学がある．現代にいきる我々も当然その思想に従うべきで，CLI ツールを作るならその哲学を踏襲するのが常識だ．&lt;/p&gt;

&lt;h1 id=&#34;unix-哲学:af878eaf4b795ed1048a236a234c7ca6&#34;&gt;UNIX 哲学&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;Small is beautiful.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Make each program do one thing well.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Build a prototype as soon as possible.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Choose portability over efficiency.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Store data in flat text files.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Use software leverage to your advantage.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Use shell scripts to increase leverage and portability.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Avoid captive user interfaces.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Make every program a Filter.&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;これは UNIX 哲学の基本思想で Go 言語ツールを作る上でいいように解釈すると，以下のことだと思っている．&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Minimal で Enough なソフトウェア設計であること&lt;/li&gt;
&lt;li&gt;他のプログラムと協調できるように，標準入出力を活用せよ&lt;/li&gt;
&lt;li&gt;外部データを使うならフラットテキスト（JSON、YAML、TOML など）を利用せよ&lt;/li&gt;
&lt;li&gt;ポータビリティを優先し，苦痛なくインストールできることを目指せ&lt;/li&gt;
&lt;li&gt;対話インタフェースは避け，フィルタとして振る舞えること&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;これについて言及している記事があるのでこれらも非常に参考になる．また，&lt;a href=&#34;http://deeeet.com&#34;&gt;@deeeet&lt;/a&gt; (a.k.a. Taichi Nakashima) さんは CLI デベロッパとしてとても有益な記事・ツールが多いのでマスト watch だ．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/talking/2014/08/31/yapc-2014/&#34;&gt;コマンドラインツールについて語るときに僕の語ること&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2014/08/27/cli-reference/&#34;&gt;コマンドラインツールを作るときに参考にしている資料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;コマンドラインツールをつくるときのガイドライン:af878eaf4b795ed1048a236a234c7ca6&#34;&gt;コマンドラインツールをつくるときのガイドライン&lt;/h1&gt;

&lt;p&gt;Go 言語で作る場合も，ご多分に漏れずこの UNIX 哲学をベースに作っていくことになる．しかし，これは Go 言語だけの話ではないが，コマンドラインツールを作る上で At least であり Most important な概念がある．&lt;/p&gt;

&lt;p&gt;それは，&lt;strong&gt;標準入出力をきちんと使い分ける&lt;/strong&gt;ことだ．これに関して，パイプの開発者 M.D.マキルロイも次のように要約している．&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;これがUNIXの哲学である。
一つのことを行い、またそれをうまくやるプログラムを書け。
協調して動くプログラムを書け。
標準入出力（テキスト・ストリーム）を扱うプログラムを書け。標準入出力は普遍的インターフェースなのだ。&lt;/p&gt;

&lt;p&gt;— M. D. マキルロイ、UNIXの四半世紀&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;コマンドラインでは，正常終了をゼロ値，異常終了を非ゼロ値として扱う．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ ./not-found-command
$ echo $?
1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;エラーかどうかを判断するのにこの終了ステータスを使うからだ．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ ./not-found-command || echo &amp;quot;Error!&amp;quot;
Error!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして，このときのエラーレポートは標準エラー出力に出力するべきだ．以下では，標準出力であるファイルディスクリプタ1番を標準エラー出力である2番に出力先を変更している．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ ./not-found-command || echo &amp;quot;Error!&amp;quot; 1&amp;gt;&amp;amp;2
Error!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうすることで，簡単に出力先をコントロールでき，処理を切り分けることができる．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/b4b4r07/items/9ea50f9ff94973c99ebe&#34;&gt;シェルスクリプトを書くときに気をつける9箇条&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/mollifier/items/95a294f95f5977b9d663&#34;&gt;シェルスクリプトのオプション設計ガイドライン&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;go-言語で作る:af878eaf4b795ed1048a236a234c7ca6&#34;&gt;Go 言語で作る&lt;/h1&gt;

&lt;p&gt;標準入出力，特に標準出力と標準エラー出力をきちんと使い分けることは，テスタブルなコマンドラインツールを設計することに直結する．しかし意外とこれが難しく，筆者もどう書けばいいか苦労していた．シェルスクリプトで実装する場合はとても簡単だ．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#...

if [ ! -f &amp;quot;$file&amp;quot; ]; then
	echo &amp;quot;$file: not found&amp;quot; 1&amp;gt;&amp;amp;2
	exit 1
fi

main
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上の例では，特定のファイルが存在しない場合，簡単なエラーレポートを標準エラー出力に流し，ステータスコード &lt;code&gt;1&lt;/code&gt; で &lt;code&gt;exit&lt;/code&gt; している．ちなみに，コマンドラインツールを設計する上で，エラー時の出力は最小限であるべき（静かなエラー）で，正常終了時は出力をしないべきなのである．これは他のツールと協調するため（出力を無視させたり整形させる手間をとらせない）とされている．&lt;/p&gt;

&lt;p&gt;これを Go 言語化する上で難しいのは次の点だ．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;終了ステータスをゼロと非ゼロで分ける&lt;/li&gt;
&lt;li&gt;そのときのエラーレポートは標準エラー出力に行う&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Go 言語では関数の戻り値を複数取れるが，エラーをともなう処理を行う関数の場合，二値目には Error を返すことが一般的だ．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func someFunc() (string, error) {
	//...
	if err != nil {
		return str, err
	}
	//...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そしてそれを最終的に一番ユーザに近いレイヤーである &lt;code&gt;main()&lt;/code&gt; で受け取り，エラーレポートとともに，&lt;code&gt;exit&lt;/code&gt; する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
	//...
	_, err := someFunc(); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
	//...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果としては期待されていた実装ができているように思える．しかし，これはアンテスタブルで，「コマンドラインツールのエラー」としては扱いきれていない．筆者も悩んでいたところ，これもまた &lt;a href=&#34;http://deeeet.com&#34;&gt;@deeeet&lt;/a&gt; さんのエントリではあるが，その問題点を完璧に克服していたので紹介したい．&lt;/p&gt;

&lt;h1 id=&#34;go-言語で設計する:af878eaf4b795ed1048a236a234c7ca6&#34;&gt;Go 言語で設計する&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2014/12/18/golang-cli-test/&#34;&gt;Go言語でテストしやすいコマンドラインツールをつくる&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;この記事では&lt;strong&gt;テスタブルな&lt;/strong&gt;ツールづくりにフォーカスしている．また，ファイル構成は最低限2つのファイル，&lt;code&gt;main.go&lt;/code&gt; と終了ステータスと標準入出力をハンドリングした &lt;code&gt;cli.go&lt;/code&gt; から成る．&lt;/p&gt;

&lt;h2 id=&#34;終了ステータスをハンドリングする:af878eaf4b795ed1048a236a234c7ca6&#34;&gt;終了ステータスをハンドリングする&lt;/h2&gt;

&lt;p&gt;まず，問題なのが，終了ステータス値（*zero or non zero*）を Go 言語側から扱えていない点だ．これについて，&lt;code&gt;int&lt;/code&gt; 型の終了値を返す関数（後述するがメソッドとして）を定義する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (cli *CLI) Run(args []string) int {
	//...
	if _, err := os.Stat(someFile); err != nil {
		err := fmt.Sprintf(&amp;quot;%s: no such file or directory&amp;quot;, someFile)
		fmt.Fprintln(cli.errStream, err)
		return ExitCodeFileNotFound
	}
	//...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;os.Exit(1)&lt;/code&gt; するのではなく，&lt;code&gt;return err&lt;/code&gt; するのでもなく，&lt;code&gt;int&lt;/code&gt; でエラーの数値を返すのだ．もちろん，&lt;code&gt;0&lt;/code&gt; 以外の数値であるが，これについても可読性のために以下のように定数として定義しておく．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const (
	ExitCodeOK    int = 0
	ExitCodeError int = 1 + iota
	ExitCodeFileNotFound
	ExitCodeParseError
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうすることで，終了値をエラーハンドリングしやすくなるし，コードとしての見通しも良くなる．エラーレポートに関しては，そのままその関数内で &lt;code&gt;fmt.Fprintf()&lt;/code&gt; して問題ない．端末画面上に出力するだけのステイトメントについては，この場合ハンドリングするべき対象でもないし，そのまま &lt;code&gt;main()&lt;/code&gt; に伝わり，&lt;code&gt;cli.errStream&lt;/code&gt; に出力される．&lt;/p&gt;

&lt;h2 id=&#34;ディスクリプタをハンドリングする:af878eaf4b795ed1048a236a234c7ca6&#34;&gt;ディスクリプタをハンドリングする&lt;/h2&gt;

&lt;p&gt;次は標準入出力の制御だ．&lt;code&gt;os&lt;/code&gt; パッケージにもあるとおり，&lt;code&gt;os.Stdout&lt;/code&gt; と &lt;code&gt;os.Stderr&lt;/code&gt; によって操作できるが，テスタブルに書くためには以下のようにするのがよい．&lt;/p&gt;

&lt;p&gt;まず，&lt;code&gt;io.Writer&lt;/code&gt; の &lt;code&gt;outStream&lt;/code&gt; と &lt;code&gt;errStream&lt;/code&gt; をフィールドとしてもつ構造体 &lt;code&gt;CLI&lt;/code&gt; を定義し，その &lt;code&gt;CLI&lt;/code&gt; 構造体をレシーバとし，またコマンドライン引数をその引数としてもつ &lt;code&gt;Run()&lt;/code&gt; メソッドを定義する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type CLI struct {
	outStream, errStream io.Writer
}

func (cli *CLI) Run(args []string) int {
	//...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前項でも書いたとおり &lt;code&gt;Run()&lt;/code&gt; では（オプション引数がある場合はそのパース処理と）具体的なコマンドの処理内容を記述し，戻り値としてステータスコードを返すようにする．&lt;/p&gt;

&lt;p&gt;あとは，&lt;code&gt;main()&lt;/code&gt; 内での記述だが，大方の処理や操作を &lt;code&gt;Run()&lt;/code&gt; メソッドで奪ったのでこれだけでよい．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//...

func main() {
    cli := &amp;amp;CLI{
    	outStream: os.Stdout,
    	errStream: os.Stderr,
    }
    os.Exit(cli.Run(os.Args[1:]))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;コマンドラインツールをテストする:af878eaf4b795ed1048a236a234c7ca6&#34;&gt;コマンドラインツールをテストする&lt;/h2&gt;

&lt;p&gt;コマンドラインツールにおいてもテストは大事だが本稿の趣旨から外れるのと，先に挙げた記事と丸かぶりしかねなくなるので，それについては省略する．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/yuya_takeyama/items/c4211fa77488cb6915ec&#34;&gt;I/O を伴うテストには bytes.Buffer が便利&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yuya-takeyama.github.io/presentations/2014/11/30/gocon_2014_autumn/&#34;&gt;Unit-testing programs depend on I/O in Go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2014/12/18/golang-cli-test/&#34;&gt;Go言語でテストしやすいコマンドラインツールをつくる&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;優れたコマンドラインツールとは:af878eaf4b795ed1048a236a234c7ca6&#34;&gt;優れたコマンドラインツールとは&lt;/h1&gt;

&lt;p&gt;UNIX 哲学に準拠していて，ストリームをきちんと理解できているツールは素晴らしい．筆者自身も試行錯誤しながら作っている．これは実装言語に依らない思想や考え方なので，CLI デベロッパは「UNIX という考え方」を参照するべきだ．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/518ME653H3L.jpg&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;参考:af878eaf4b795ed1048a236a234c7ca6&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.songmu.jp/riji/entry/2015-04-18-commandline-tool-design.html&#34;&gt;コマンドラインツールを作るときに考えているちょっとした設計方針&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://yohshiy.blog.fc2.com/blog-entry-260.html&#34;&gt;コマンドラインプログラムにおける引数、オプションなどの標準仕様&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://yuuki.hatenablog.com/entry/go-cli-unix&#34;&gt;Go言語によるCLIツール開発とUNIX哲学について&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Golang でコマンドラインにゴミ箱を実装した話</title>
      <link>http://tellme.tokyo/post/2015/05/22/gomi/</link>
      <pubDate>Fri, 22 May 2015 00:00:00 +0900</pubDate>
      
      <guid>http://tellme.tokyo/post/2015/05/22/gomi/</guid>
      <description>

&lt;h1 id=&#34;まえがき:562e4d040771234bd98b731edec0bf65&#34;&gt;まえがき&lt;/h1&gt;

&lt;p&gt;デスクトップに一際目立つアイコンで鎮座する，&lt;a href=&#34;http://ja.wikipedia.org/wiki/ごみ箱_(GUI)&#34;&gt;ゴミ箱&lt;/a&gt;は使っているだろうか．今となってはゴミ箱は GUI デスクトップの象徴的存在だ．誤削除を防ぐ手段としても，安心した削除支援の存在としても GUI デスクトップに無くてはならない．&lt;/p&gt;

&lt;p&gt;さて，GUI デスクトップに相当する CLI はホームディレクトリだが，これにゴミ箱がないのは不便ではないだろうか．&lt;code&gt;rm&lt;/code&gt; に関してはその概念をなくして削除を行い，他に「ゴミを捨てる」にあたるようなコマンドはない．&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;GUI以前のコマンドラインには、ゴミ箱という考え方はなかった。（と思う）ファイルやフォルダを削除するにはrmコマンドを使っていた。そのまま使えば、rmを実行した瞬間にファイルは削除される。あるいは、-iオプションによって、削除する前に確認メッセージも表示できるが、yを選択した瞬間にファイルは削除される。&lt;/p&gt;

&lt;p&gt;だから、ゴミ箱というフォルダに移動して一時的に保存しておくという考え方は、画期的なことだと思った。なぜなら、間違って必要なファイルを捨ててしまうこともあるからだ。rmコマンドでは削除を取り消せないが、ゴミ箱に移動しただけなら、必要なファイルを元の場所に戻せば救われるのである。この辺は、リアルな世界のゴミ箱の機能に近い。（ゴミ箱をあさった経験は、少なからず誰しもあると思う） via &lt;a href=&#34;http://d.hatena.ne.jp/zariganitosh/20110106/best_trash&#34;&gt;後悔しない最高のゴミ箱環境を模索する&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;むしろなんで今までなかったのだろう．CLI の習熟度に関わらず，まれに重要なファイルを誤って消しそうになることもあるし，他には例えばチルダ付きのファイルを消そう（&lt;code&gt;rm ~/*~&lt;/code&gt;）として余計にスペースが入った（&lt;code&gt;rm ~/* ~&lt;/code&gt;）と，いいようなタイポによる誤削除は往々にしてあり得る．&lt;/p&gt;

&lt;p&gt;筆者にも同様の経験があり，それ以後ゴミ箱を実装したスクリプトを書いて利用していた．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/b4b4r07/dotfiles/blob/master/etc/scripts/rmr.sh&#34;&gt;b4b4r07/rmr.sh&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;このスクリプトは，削除に関してはいいのだが（&lt;code&gt;~/.rmtrash&lt;/code&gt; に &lt;em&gt;YYYY/MM/DD/file.H_M_S&lt;/em&gt; でアーカイブする），取り出すときに元ファイルのパス情報その他が失われてしまうため，リストアが困難なのが欠点だった（今は少し改良をしていて &lt;code&gt;peco&lt;/code&gt; 経由でリストアするようになっている）．&lt;/p&gt;

&lt;p&gt;GUI のそれのように CLI でも削除後に簡単に「戻す」ができたら便利だと思い，調べてみたところ以下のリポジトリが GitHub でスターを多く獲得していた．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/andreafrancia/trash-cli&#34;&gt;andreafrancia/trash-cli&lt;/a&gt; &lt;a href=&#34;https://github.com/andreafrancia/trash-cli&#34; title=&#34;andreafrancia/trash-cli&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/stars/andreafrancia/trash-cli.svg?style=flat-square&#34; alt=&#34;&#34; /&gt;
&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;Command line interface to the freedesktop.org trashcan.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/sindresorhus/trash&#34;&gt;sindresorhus/trash&lt;/a&gt; &lt;a href=&#34;https://github.com/sindresorhus/trash&#34; title=&#34;sindresorhus/trash&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/stars/sindresorhus/trash.svg?style=flat-square&#34; alt=&#34;&#34; /&gt;
&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;Cross-platform command-line app for moving files and directories to the trash - A safer alternative to &lt;code&gt;rm&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;trash-cli:562e4d040771234bd98b731edec0bf65&#34;&gt;trash-cli&lt;/h1&gt;

&lt;p&gt;前者は Python 製のゴミ箱スクリプトのようだ．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;trash-put&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;trash-empty&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;trash-list&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;trash-restore&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;trash-rm&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;詳しいインストール方法は README を参照していただきたいが、&lt;code&gt;easy_install trash-cli&lt;/code&gt; とした後に、5 つの専用コマンドがインストールされ，それぞれを削除やリストアのときに使い分けるようになっている．古典的な実装・Usage と言わざるを得ない感じで，正直 5 つのコマンドを使い分けるのは面倒です。&lt;/p&gt;

&lt;p&gt;加えて，肝心なリストア部分は，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ trash-restore
0 2007-08-30 12:36:00 /home/andrea/foo
1 2007-08-30 12:39:41 /home/andrea/bar
2 2007-08-30 12:39:41 /home/andrea/bar2
3 2007-08-30 12:39:41 /home/andrea/foo2
4 2007-08-30 12:39:41 /home/andrea/foo
What file to restore [0..4]: 4
$ ls foo
foo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;といった具合に，復元したいファイルをナンバーで指定して選択できるようになっている．このユーザインターフェイスは「戻す」ことを簡単に行える設計と言える．UNIX の哲学ではインタラクティブなコマンド設計は良しとされないが，今回は対話性が必要なユースケースの一つであろう．&lt;/p&gt;

&lt;p&gt;基本的に Python の実行環境を整えればどこでも動作するが，きちんと動く Python 環境をセットアップするのは（少なくとも筆者は）面倒にしか感じない．&lt;/p&gt;

&lt;p&gt;そしてもうひとつ欠点は開発が停滞している点だ．メンテナンスもされていない．&lt;/p&gt;

&lt;h1 id=&#34;trash:562e4d040771234bd98b731edec0bf65&#34;&gt;trash&lt;/h1&gt;

&lt;p&gt;後者は Node.js によって実現したゴミ箱スクリプトだ．&lt;/p&gt;

&lt;p&gt;OS 標準のゴミ箱に捨てれる点が良い．しかし，リストアができないようだ（OS のゴミ箱の「戻す」機能を使えば可能となるが，GUI 操作を要する）．また，ただゴミ箱に投げるだけなのでファイル名のコンフリクトも発生する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ trash --help

  Usage
    trash [--force] &amp;lt;path&amp;gt; [&amp;lt;path&amp;gt; ...]

  Example
    trash unicorn.png rainbow.png
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;システム連携に目を輝かせたが，実際の使い勝手はよろしくなかった．&lt;/p&gt;

&lt;h1 id=&#34;そこで他の案:562e4d040771234bd98b731edec0bf65&#34;&gt;そこで他の案&lt;/h1&gt;

&lt;p&gt;他にはどんな方法があるのか調べてた．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rcmdnk/trash&#34;&gt;rcmdnk/trash&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dankogai/osx-mv2trash&#34;&gt;dankogai/osx-mv2trash&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://launchpad.net/safe-rm&#34;&gt;safe-rm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;個々人で簡易的に実装したものだったりが多い．筆者のケースを解決するのに満足なツールはなかった．&lt;/p&gt;

&lt;p&gt;そこで，全ての欠点を解消し，尚かつ利点を包括的に取り込んだ，オリジナルのゴミ箱スクリプトを作るしかないと考えた（Unix らしく）．&lt;/p&gt;

&lt;h1 id=&#34;gomi:562e4d040771234bd98b731edec0bf65&#34;&gt;gomi&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/b4b4r07/gomi&#34; title=&#34;b4b4r07/gomi&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/b4b4r07/screenshots/master/gomi/logo.png&#34; alt=&#34;&#34; /&gt;
&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/b4b4r07/gomi&#34;&gt;b4b4r07/gomi&lt;/a&gt; &lt;a href=&#34;https://github.com/b4b4r07/gomi&#34; title=&#34;b4b4r07/gomi&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/stars/b4b4r07/gomi.svg?style=flat-square&#34; alt=&#34;&#34; /&gt;
&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;gomi is a simple trash tool that works on CLI, written in golang&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;コイツはもの凄く便利だ．構想段階ではここまで便利になるとは思わなかった．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;クロスプラットフォーム，Mac でも Windows でも Linux でも&lt;/li&gt;
&lt;li&gt;シングルバイナリ，バイナリひとつあれば Python も Node.js も要らない&lt;/li&gt;
&lt;li&gt;リストアが簡単，&lt;a href=&#34;https://github.com/peco/peco&#34;&gt;peco/peco&lt;/a&gt; みたいなセレクタを備える&lt;/li&gt;
&lt;li&gt;クイックビュー（OS X でいう QuickLook ができる），リストアする前に捨てたファイルの中身を確認&lt;/li&gt;
&lt;li&gt;リストアしたい複数のファイルを選択して，カレントディレクトリに引っ張ってくるとかできる&lt;/li&gt;
&lt;li&gt;OS 標準のゴミ箱と連携できる&lt;/li&gt;
&lt;li&gt;もちろん，リストアは gomi からでも，GUI の「戻す」からでも OK&lt;/li&gt;
&lt;li&gt;YAML 形式の設定ファイルでカスタマイズできる

&lt;ul&gt;
&lt;li&gt;例：リストア時に参照するログファイルに追加したくないファイルなど（例えば，.DS_Store といった復元を求めないファイル）&lt;/li&gt;
&lt;li&gt;例：ゴミ箱に入れるファイルのサイズ上限（デフォルトは1GB）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これだけでもかなり便利です．下の GIF を参照されたい．&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/b4b4r07/gomi&#34; title=&#34;b4b4r07/gomi&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/b4b4r07/screenshots/master/gomi/demo.gif&#34; alt=&#34;b4b4r07/gomi&#34; /&gt;
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;めっちゃ便利．&lt;/p&gt;

&lt;h2 id=&#34;インストール:562e4d040771234bd98b731edec0bf65&#34;&gt;インストール&lt;/h2&gt;

&lt;p&gt;Homebrew の Mac ユーザなら，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ brew tap b4b4r07/gomi
$ brew install gomi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で OK ．&lt;/p&gt;

&lt;p&gt;Go 言語ユーザや開発者向けには，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ go get -u github.com/b4b4r07/gomi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go でインストールできる．&lt;/p&gt;

&lt;p&gt;その他のユーザに関しては，各プラットフォーム向けにコンパイルした実行ファイルが GitHub の &lt;a href=&#34;https://github.com/b4b4r07/gomi/releases&#34;&gt;releases page&lt;/a&gt; にアップロードしてあるので，バイナリをダウンロードして &lt;code&gt;$PATH&lt;/code&gt; のどこかに移動すればよい．&lt;/p&gt;

&lt;h2 id=&#34;使い方:562e4d040771234bd98b731edec0bf65&#34;&gt;使い方&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ gomi files    # 削除する（複数ファイルまとめて削除もOK）
$ gomi -r       # 元ある場所に戻す
$ gomi -r .     # カレントディレクトリに戻す
$ gomi -s file  # OS のゴミ箱に捨てる
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;詳しくは，&lt;a href=&#34;https://github.com/b4b4r07/gomi&#34;&gt;README.md&lt;/a&gt; まで．&lt;/p&gt;

&lt;h1 id=&#34;最後に:562e4d040771234bd98b731edec0bf65&#34;&gt;最後に&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://qiita.com/b4b4r07/items/3a790fe7e925b4ba14f3&#34;&gt;Go 言語で rm 用ごみ箱ツール gomi を作った&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;一度，Qiita に公開した．この時はまだ β 版だったが，安定版を提供できるところまではきたかなといった感じなので．&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>